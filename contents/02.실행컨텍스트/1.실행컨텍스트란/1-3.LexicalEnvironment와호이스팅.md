<p>

#### [back](../../../README.md) &nbsp;&nbsp; | &nbsp;&nbsp; write by [Local](https://github.com/blocallee)

</p>

# 1-3 LexicalEnvironment와 호이스팅

<p align="center">
    <img src="../../../image/main.png">
<p> * 이 글은 코어자바스크립트 책을 참고하여 기록하였습니다. </p>
</p>

---

<br>

## LexicalEnvironment

> 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것.

<br>

<P>한국어 번역은 문서마다 제각각 다르다.</p>
<p>

`어휘적` 환경, `정적` 환경 이라는 단어가 가장 많이 등장하는데</p>

<p>

`어휘적` 은 영어사전에 대입해서 치환한거라 의미가 와 닿지 않고</p>

<p>

`정적` 은 수시로 변하는 환경 정보를 의미하는 'lexical environment'에 대해 적절한 번역이라고 볼 수 없다.</p>

<p>예를 들면</p>
<p>백과사전에서 '바나나'를 검색하면 가장 먼저 '칼로리가 가장 높고 당질이 많은 알칼리성 식품으로 칼륨, 카로틴, 비타민C를 함류하고 있다.'라는 문구가 등장한다 </p>
<p>한마디로</p>
<p>현재 컨텍스트 내부에는 a,b,c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성돼있다</p>

<br>

> '사전적 환경'이라는 번역은 필자의 사견일 뿐이다.

<p>어떤 용어를 대할 때</p>

- 개인의 이해를 위한 용어

또는

- 타인과의 커뮤니케이션을 위한 용어

<p>두 가지로 본다면</p>
<p>

`사전적 환경`은 어디까지나 전자, **'개인의 이해를 위한 용어'** 해당되며</p>

<p>후자를 위해서는 가급적 원어를 문자 그대로 받아들이는 편이 좋다.</p>

```
variable Environment 역시 마찬가지로
'변수 환경' 이 아닌
variable Environment 라는 원어 그대로 사용하겠다.
```

<br>
<br>
<br>

## environmentRecord 호이스팅

> environmentRecord 에는 현재 컨텍스트와 관련되 코드의 식별자 정보들이 저장된다.

<br>

<p>컨텍스트를 구성하는 함수에 지정된</p>

- 매개변수 식별자
- 선언한 함수

<p> 가 있을 경우 그 함수 자체,</p>
<p>var로 선언된 변수의 식별자 등이 식별자에 해당한다.</p>

```
컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며
"순서대로" 수집한다.
```

<details>
<summary>참고</summary>

<br>

<p>전역 실행 컨텍스트는</p>
<p>변수 객체를 생성하는 대신</p>
<p>자바스크립트 구동 환경이 별도로 제공하는 객체,</p>
<p>즉 전역 객체(global object)를 활용한다.</p>
<p>전역 객체는</p>
<p>브라우저의 window, Node.js의 global 객체등이 있다.</p>
<p>이들은 자바스크립트 내장 객체(native object)가 아닌</p>
<p>호스트 객체(host object)로 분류된다.</p>
</details>

<br>
<br>

<p>변수 정보를 수집하는 과정은 모두 마쳤더라도</p>
<p>아직 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태이다.</p>
<p>코드가 실행되기 전임에도 불구하고</p>

```
자바스크립트 엔진은 이미 해당 환경에 속한
코드의 변수명들을 모두 알고 있는 셈이다.
```

<br>

<p>그렇다면 엔진의 실제 동작 방식 대신에</p>

```
'자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다'
```

<p>라고 생각하더라도 코드를 해석하는 데는 문제될 것이 전혀 없을 것이다.</p>

<br>

<p>여기서 호이스팅hoisting 이라는 개념이 등장한다.</p>
<p>호이스팅이란 '끌어올리다' 라는 의미의 hoist에 ing를 붙여 만든 동명사로</p>
<p>변수 정보를 수집하는 과정을  더욱 이해하기 쉬운 방법으로 대체한 가상의 개념이다.</p>
<p>자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하는 것.</p>

<br>
<br>
<br>

## 호이스팅 규칙

<p>

`environmentRecord`에는</p>

- 매개변수의 이름
- 함수 선언
- 변수명
- 등이

<p>담긴다고 했다.</p>

<p>몇 가지 예제를 통해 알아보자.</p>

<br>
<br>

<p>

매개변수와 변수에 대한 호이스팅`(1)` - 원본코드</p>

<p align="center">예제 2-2.</p>

```
function a(x) {     // 수집 대상 1(매개변수)
  console.log(x);   // (1)
  var x;            // 수집 대상 2(변수 선언)
  console.log(x);   // (2)
  var x = 2;        // 수집 대상 2(변수 선언)
  console.log(x);   // (3)
}
a(1);
```

<p>

우선 **`호이스팅이 되지 않았을 때`**</p>

<p>

(1), (2), (3) 에서 어떤 값들이 출력될지를 `예상`해보자.</p>

- `(1)` 에는 함수 호출 시 전달한 `1`이 출력
- `(2)` 는 선언된 변수 x에 할당한 값이 없으므로 `undefined`가 출력
- `(3)` 에서는 `2`가 출력

```
    🚨주의🚨
    지금부터 자바스크립트 엔진의 구동 방식을
    좀 더 사람 입장에서 이해해보고자 코드를 몇 차례 변경할 것이다.
    실제 엔진은 이러한 변환 과정을 거치치 않는다.
```

<p>

`예제 2-2`처럼</p>

<p>

**인자들과 함계 함수를 호출한 경우의 동작** 을 살펴보면,</p>

<p>

`arguments`에 전달된 인자를 담는 것을 제외하면</P>

<details>
<summary>💡 arguments </summary>
<p>이 역시 실행 컨텍스트 생성 시점에 함께 만드는 정보 중 하나이다.</p>
<p>지정한 매개변수의 개수와 무관하게 호출 시 전달한 인자가 모두 arguments 정보로 담긴다.</p>
<p>이러한 특성 덕분에 기존에는 함수의 자율성을 높이는 측면에서</p>
<p>arguments를 광범위하게 활용했다.</p>

</details>

<br>

<p>

다음의 `예제 2-3`처럼</P>

<p>코드 내부에서 변수를 선언한 것과 다른 점이 없다.</p>

```
특히 LexicalEnvironment 입장에서는 완전히 같다
```

<p>인자를 함수 내부의 다른 코드보다 먼저 선언 및 할당이 이뤄진 것으로 간주 할 수 있다.    </p>

<br>
<br>

<p>

매개변수와 변수에 대한 호이스팅`(2)`</p>

<p>-  매개변수를 변수 선언/할당과 같다고 가준해서 변환한 상태</p>
<p align="center">예제 2-3.</p>

```
function a() {
  var x = 1;        // 수집 대상 1(매개변수 선언)
  console.log(x);   // (1)
  var x;            // 수집 대상 2(변수 선언)
  console.log(x);   // (2)
  var x = 2;        // 수집 대상 2(변수 선언)
  console.log(x);   // (3)
}
a(1);
```

<p>이 상태에서 변수 정보를 수잡하는 과정,</p>
<p>

즉, **호이스팅 처리를 해보자**</p>

<br>

`environmentRecord`

- `유`관심 : 현재 실행될 컨텍스트의 대상 코드 내에 `어떤 식별자들이 있는지`.
- `무`관심 : 각 식별자에 어떤 값이 `할당`될 것인지.

<p>따라서 변수를 호이스팅할 때</p>
<p>변수명만 끌어올리고</p>
<p>할당 과정은 원래 자리에 그대로 남겨둔다.</p>
<p>매개변수도 마찬가지.</p>

<br>
<br>

<p>environmentRecord의 관심사에 맞춰 </p>
<p>수집 대상 1,2,3을 순서대로 끌어올리고 나면 다음과 같은 형태로 바뀐다.</p>

<br>

<p>

매개변수와 변수에 대한 호이스팅 `(3)`</p>

<p>-  매개변수를 변수 선언/할당과 같다고 가준해서 변환한 상태</p>
<p align="center">예제 2-3.</p>

```
01  function a() {
02    var x;            // 수집 대상 1의 변수 선언 부분
03    var x;            // 수집 대상 2의 변수 선언 부분
04    var x;            // 수집 대상 3의 변수 선언 부분
05
06    x = 1;            // 수집 대상 1의 할당 부분
07    console.log(x);   // (1)
08    console.log(x);   // (2)
09    x = 2;            // 수집 대상 3의 할당 부분
10    console.log(x);   // (3)
11  }
12  a(1);
```

- 02 &nbsp; `var x;`
  1. 변수 `x` 선언.
     - 이때 메모리에서는 저장할 공간 미리 확보
  2. 확보한 공간의 주솟값을 변수 `x`에 연결

<br>

- 03, 04 &nbsp; `var x;`
  1. 다시 변수 `x` 선언.
  2. 이미 선언된 변수가 있으므로 무시.

<br>

- 06 &nbsp; `x = 1;`
  1. x를 `1`에 할당하라고 지시.
     - 우선 숫자 `1`을 별도의 메모리에 담고
     - x와 연결된 메모리 공간에 숫자 `1`을 가리키는 주솟값 입력.

<br>

- 07, 08 &nbsp; `console.log(x);`
  1. 각 `x`를 출력하라고 지시.
  2. `(1)`, `(2)` 모두 `1`이 출력

<br>

- 09 &nbsp; `x = 2;`

  1. `x`에 `2`를 할당하라고 지시.
     - 숫자 `2`를 별도의 메모리에 담고
     - 그 주솟값을 든 채로 `x`와 연결된 메모리 공간으로 이동.
     - 여기에는 숫자 `1`을 가리키는 주솟값이 들어있는 상태.
     - 이걸 `2`의 주솟값으로 대치.
     - 이제 변수 x는 숫자 `2`를 가리키는 상태.

<br>

- 10 &nbsp; `console.log(x);`
  1. `2`가 출력.
  2. 출력 후 함수 내부의 모든 코드 실행 완료로 실행 컨텍스트가 콜 스택에서 제거됨.

<br>

<p>다음과 같이 출력될 것으로 예상했지만</p>

- `(1)`은 `1`
- `(2)`는 `undefined`
- `(3)`는 `2`

<p>실제로는 다음과 같은 결과가 나왔다.</p>

- `(1)`은 `1`
- `(2)`는 `1`
- `(3)`는 `2`

<p>호이스팅 개념을 정확히 이해하지 못하면 예측하기 어려운 결과인다.</p>

<br>
<br>

<p>

다음은
`함수 선언을 추가한 예제`.&nbsp;&nbsp;
(앞의 예제와 동일한 순서로 진행)</p>

<p>

함수 선언의 호이스팅 `(1)` - 원본 코드</p>

<p align="center">예제 2-5.</p>

```
01  function a() {
02    console.log(b);   // (1)
03    var b = 'bbb';    // 수집 대상 1(변수 선언)
04    console.log(b);   // (2)
05    function b(){}    // 수집 대상 2(함수 선언)
06    console.log(b)    // (3)
07  }
08  a();
```

<p>

(1), (2), (3) 에서 어떤 값들이 출력될지 `예상` 결과.</p>

- `(1)` b의 값이 없으니 에러 또는 `undefined` 출력
- `(2)` 는 `'bbb'`
- `(3)` 는 `b함수`

<br>

<p>실제로도 그런지 살펴보자</p>

```
 a 함수 실행
```

- 실행하는 순간 `a`함수의 실행 컨텍스트 생성
- 이 때 `변수명`과 `함수 선언의 정보`를 위로 끌어올린다(수집한다)
- `변수`는 선언부와 할당부를 나누어 `선언부`만 끌어올리는 반변에
- `함수 선언`은 `함수 전체`를 끌어올린다.

<br>
<br>

<p>

수집 대상 `1`과 `2`를 순서대로 끌어올리고 나면
다음과 같은 형태로 변환된다.</p>

<p>

함수 선언의 호이스팅 `(2)` - 호이스팅 마친 상태</p>

<p align="center">예제 2-6.</p>

```
01  function a() {
02    var b;            // 수집 대상 1. 변수는 선언부만 끌어올린다.
03    function b(){}    // 수집 대상 2. 함수 선언은 전체를 끌어올린다.
04
05    console.log(b)    // (1)
06    b = 'bbb';        // 변수의 할당부는 원래 자리에 남겨둔다.
07    console.log(b)    // (2)
08    console.log(b)    // (3)
09  }
10  a();
```

<br>
<br>

<p>

해석의 편의를 위해 `예제 2-6`에서 한 가지만 더 바꿔보자.</p>

```
호이스팅이 끝난 상태에서의 함수 선언문은
함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있다.
```

<p>

함수 선언의 호이스팅 `(3)` - 함수 선언문을 함수 표현식으로 바꾼 코드</p>

<p align="center">예제 2-7.</p>

```
01  function a() {
02    var b;
03    var b = function b(){}    // <- 바뀐 부분
04
05    console.log(b)    // (1)
06    b = 'bbb';
07    console.log(b)    // (2)
08    console.log(b)    // (3)
09  }
10  a();
```

<p>코드를 차례대로 실행해보자</p>

- 02 &nbsp; `var b;`
  1. 변수 `b` 선언.
     - 이때 메모리에서는 저장할 공간 미리 확보
     - 확보한 공간의 주솟값을 변수 `b`에 연결

<br>

- 03 &nbsp; `var b = function b () {};`
  1. 다시 변수 `b` 선언하고 `함수 b`를 선언된 변수 `b`에 할당.
     - 이미 선언된 변수 `b`가 있으므로 선언과정은 무시.
     - 함수는 별도의 메모리에 담길 것이고
     - 함수가 저장된 주솟값을 `b`와 연결된 공간에 저장.

<br>

- 05 &nbsp; `console.log(b);`
  1. 변수 `b`에 할당된 `함수 b`를 출력한다 `(1)`

<br>

- 06 &nbsp; `b = 'bbb';`
  1. 변수 `b`에 `'bbb'`를 할당 지시.
     - `b`와 연결된 메모리 공간에는 함수가 저장된 주솟값이 담겨 있고
     - 이 주솟값을 문자열 `'bbb'`가 담긴 주솟값으로 덮어쓴다.
     - 이제 변수 `b`는 문자열 `'bbb'`를 가리킨다.

<br>

- 07, 08 &nbsp; `console.log(b);`
  1. (2), (3) 모두 'bbb' 출력.
  2. 이제 함수 내부의 모든 코드가 실행됐으므로 실행 컨텍스트가 콜 스택에서 제거.

<br>
<p>다음과 같이 출력될 것으로 예상했지만</p>

- `(1)`은 `에러` 또는 `undefined`
- `(2)`는 `bbb`
- `(3)`는 `b 함수`

<p>실제로는 다음과 같은 결과가 나왔다.</p>

- `(1)`은 `b 함수`
- `(2)`는 `bbb`
- `(3)`는 `bbb`

<br>
<br>
<br>

## 함수 선언문과 함수 표현식

<br>

### 함수 선언문 function declaration

> function 정의부만 존재하고 별도의 할당 명령이 없는 것

- `반드시` 함수명이 정의돼 있어야 한다.

<br>

### 함수 표현식 function expression

> 정의한 function을 별도의 변수에 할당하는 것

- 함수명이 정의돼 있지 않아도 된다.
- 일반적으로 `익명 함수 표현식`을 의미한다.

<br>

### 기명 함수 표현식

> 함수명을 정의한 함수 표현식

<br>
<br>

<p>함수를 정의하는 세 가지 방식</p>
<p align="center">예제 2-8.</p>

```
01  function a () { /* ... */}          // 함수 선언문. 함수명 a가 곧 변수명.
02  a();                                // 실행 OK
03
04  var b = function () { /* ... */}    // (익명) 함수 표현식. 변수명 b가 곧 함수명.
05  b();                                // 실행 OK
06
07  var c = function d () { /* ... */}  // 기명 함수 표현식. 변수명은 c, 함수명은 d
08  c();                                // 실행 OK
09  d();                                // 에러!!
```

<br>

<details>
<summary>[참고] 기명 함수 표현식 주의할 점</summary>

<br>

<p>

**`외부에서 함수명으로 함수를 호출할 수 없다`**</p>

<p>

**`함수명은 오로지 함수 내부에서만 접근 가능`**</p>

<br>

<p>그렇다면 기명 함수 표현식의 용도는?</p>
<p>

`기명 함수 표현식`은 함수명이 잘 출력됐던 반면</p>

<p>익명 함수 표현식은 undefined 또는 unnamed 라는 값이 나왔었다.</p>
<p>

이 때문에 `기명 함수 표현식이 디버깅 시 어떤 함수 인지를 추적하기에`</p>

<p>

`익명 함수 표현식보다 유리한 측면`이 있었다.</p>

<p>그러나</p>

```
이제는 모든 브라우저들이 익명 함수 표현식의 변수명을 함수의 name 프로퍼티에 할당하고 있다.
```

<p>한편</p>
<p>c 함수 내부에서는 c()로 호출하든</p>
<p>b()로 호출하든 잘 실행된다.</p>

```
따라서 함수 내부에서 재귀함수를 호출하는 용도로 함수명을 쓸 수 있다.
```

<p>다만 c()로 호출해도 되는 상황에서</p>
<p>굳이 d()로 호출해야 할 필요가 있을지는 의문.</p>

---

</details>

<br>
<br>
<p>함수 선언문과 함수 표현식의 실질적인 차이</p>
<p>

함수 선언문과 함수 표현식 `(1)` - 원본 코드</p>

<p align="center">예제 2-9.</p>

```
01  console.log(sum(1,2));
02  console.log(multiply(3,4));
03
04  function sum (a, b) {               //  함수 선언문 sum
05    return a + b;
06  }
07
08  var multiply = function (a, b) {    // 함수 표현식 multiply
09    return a * b;
10  }
```

<p>실행 컨텍스트의 LexicalEnvironment는 두 가지 정보를 수집한다.</p>
<p>

`예제 2-9`에서는 두 가지 정보 중</p>

<p>environmentRecord의 정보 수집 과정에서 발생하는 호이스팅을 살펴볼 수 있다.</p>

<br>
<br>
<p>

함수 선언문과 함수 표현식 `(2)` - 호이스팅을 마친 상태</p>

<p align="center">예제 2-10.</p>

```
01  var sum = function sum (a, b) {     // 함수 선언문은 전체를 호이스팅 한다.
02      return a + b;
03  }
04  var multiply;                       // 변수는 선언부만 끌어올린다.
05  console.log(sum(1,2));
06  console.log(multiply(3,4));
07
08  var multiply = function (a, b) {    // 변수의 할당부는 원래 자리에 남겨둔다.
09    return a * b;
10  }

```

함수 선언문

```
함수 전체를 호이스팅
```

함수 표현식

```
- 변수 선언부만 호이스팅
- 함수를 다른 변수에 값으로써 `할당`한 것.
```

<br>

<p>

함수 선언문과 함수 표현식의 극적인 `차이점`</p>

- 01 &nbsp; `var sum = function sum (a, b) {}`
  1. 메모리 공간 확보
  2. 확보된 공간의 주솟값을 `변수 sum`에 연결

<br>

- 04 &nbsp; `var multiply;`
  1. 또 메모리 공간 확보
  2. 확보된 공간의 주솟값을 `변수 sum`에 연결

<br>

- 01 (다시) &nbsp; `var sum = function sum (a, b) {}`
  1. `sum 함수`를 또 다른 메모리 공간에 저장
  2. 그 주솟값을 앞서 선언한 `변수 sum`의 공간에 할당
     - 이로써 `변수 sum`은 `함수 sum`을 바라보는 상태가 된다.

<br>

- 05 &nbsp; `console.log(sum(1,2));`
  1. `sum`을 실행
  2. 정상적으로 실행이 되어 `3`출력

<br>

- 06 &nbsp; `console.log(multiply(3,4));`
  1. (현재 multiply에는 값이 할당돼 있지 않음. 비어있는 대상을 함수로 여겨 실행하라고 명령한 것)<br> 따라서 `'multiply is not a function'이라는 에러메세지 출력`.

<br>

- 08 &nbsp; `var multiply = function sum (a, b) {}`
  1. 06번째 줄의 에러로 인해 실행되지 않은 채 런타인 종료.

<br>
<br>

```
sum 함수는 선언 전에 호출해도 아무 문제 없이 실행된다.
```

<p> 어떻게 작성해도 오류를 내지 않는 것은</p>
<p> 초급자들에겐 좀 더 쉽게 접근할 수 있게 해주는 측면도 있지만</p>
<p>

`큰 혼란을 일으키는 원인`이 되기도 한다.</p>

<br>
<br>

### 함수 선언문이 혼란스러운 개념인 이유

<p>실무에서 발생하는 현실적인 예를 살펴보자.</p>
<p>결코 모범적인 상황은 아니지만 </p>
<p>바쁜 업무를 함께 처리하는 와중에 생각보다 자주 발생하는 일일 수 있다.</p>
<br>

<p>
    상황
</p>

```
개발자 A가 sum 함수를 선언함.
인자 두 개를 받아 두 인자의 합을 반환하는 단순한 함수.

이 함수가 거대한 자바스크립트 파일 내의 100번째 줄에 위치했다고 가정하자.

A는 이 함수를 여기저기서 호출해서 잘 활용해왔다.

어느날 새로 입사한 B가
같은 파일의 5000번째 줄에서 sum 함수를 새로 선언한다.

x,y 를 받아 가독성 좋게 문자열로 "X + y = (x+y)" 를 반환하는 함수이다.

자바스크립트를 잘 모르는 B는
본인이 작성한 sum 함수가
선언한 위치인 5000번째 줄 이후에만 영향을 줄 것이라고 굳게 믿고
별대른 테스트도 거치지 않은 상태로

머지한 다음 배포까지 해버린다.
```

<br>
<p>

함수 선언문의 위험성

</p>
<p align="center">예제 2-11.</p>

```
 ...
  60    console.log(sum(3,4));
 ...
 100    function sum (x, y) {}
 101        return x + y;
 102    }
 ...
 200    var a = sum(1,2);
 ...
5000    function sum (x, y) {}
5001        return x + ' + ' +  y  + ' = ' + ( x + y );
5002    }
 ...
5010    var c = sum(1,2);
5011    console.log(c);
 ...
```

<p>전역 컨텍스트가 활성화 될 때</p>
<p>전역공간에 선언된 함수들이 모두 가장 위로 끌어올려진다.</p>
<p>이 때 동일한 변수명에 서로 다른 값을 할당할 경우</p>
<p>

**나중에 할당한 값이 먼저 할당한 값을 덮어씌운다(override)**

</p>

```
코드를 실행하는 중에 실제로 호출되는 함수는
오직 마지막에 할당한 함수,

즉 맨 마지막에 선언된 함수뿐이다.
```

<p>A가 의도했던 함수는</p>
<p>숫자로 된 결괏값을 반환하는 것이었는데</p>
<p>실제로는 전혀 다른 문자열을 반환하게 된다.</p>

```
여기저기서 문제가 생기고 있는데
정작 문제의 원인이 되는

sum함수는
아무런 에러를 내지 않는다.
```

<p>심지어</p>
<p>sum 함수의 결과를 활용하는 다른 함수에서조차</p>
<p>숫자 대신 문자열을 넘겨받았음에도</p>
<p>암묵적 형변환에 따라(비록 잘못된 값이지만)</p>
<p>오류없이 통과된다.</p>

```
문제는 전혀 쌩뚱맞은 곳에서 터지고
문제가 된 함수를 살펴봐도 도통 알 수 없다.

빨리 버그를 수정해야하는데 어떤 코드가 문제인지를
어디서부터 어떻게 찾아야 할지 엄두도 나지 않게 된다😱
```

<br>
<p>

상대적으로 함수 표현식이 안전하다

</p>
<p align="center">예제 2-12.</p>

```
 ...
  60    console.log(sum(3,4));          // uncaught Type Error: sum is not a function
 ...
 100    var sum = function (x, y) {}    // 바뀐 부분
 101        return x + y;
 102    }
 ...
 200    var a = sum(1,2);
 ...
5000    var sum = function (x, y) {}    // 바뀐 부분
5001        return x + ' + ' +  y  + ' = ' + ( x + y );
5002    }
 ...
5010    var c = sum(1,2);
5011    console.log(c);
 ...
```

<p>A와 B 모두 sum 함수를 함수 표현식으로 정의했다면</p>
<p>

5000번째 줄 `이전`까지는 A 의도대로</p>

<p>

5000번째 줄 `이후`부터는 B 의도대로</p>

<p>잘 동작했을 것이다.</p>

<br>

<p>뿐만 아니라</p>
<p>처음 sum 함수를 선언한 100번째 줄 이전에</p>
<p>sum 함수를 호출하는 코드가 있었다면</p>

```
그 줄에서 바로 에러가 검출되므로
더욱 빠른 타이밍에 손쉽게 디버깅할 수 있었을 것이다.
```

<br>

<p>극단적 예시이긴 하지만</p>
<p>원활한 협업을 위해선</p>

```
전역공간에 함수를 선언하거나
동명의 함수를 중복 선언하는 경우는 없어야 한다.
```

<p>만약 전역공간에 동명의 함수가 여럿 존재하는 상황이더라도</p>
<p>모든 함수가 함수 표현식으로 정의돼 있으면</p>
<p>위와 같은 상황은 일어나지 않을 것이다.</p>
